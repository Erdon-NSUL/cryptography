#include<bits/stdc++.h>
using namespace std;

typedef vector<int> col;
//明文,这里用了互转置矩阵
vector<col> M16 = {
	{0x45,0x67,0x67,0x73},
	{0x61,0x72,0x65,0x67},
	{0x72,0x65,0x61,0x74},
	{0x66,0x6F,0x6F,0x64}
};
//密钥，同样转置矩阵
vector<col> ORIKEY16 = {
    {0x6A, 0x69, 0x6E, 0x69},
    {0x74, 0x61, 0x69, 0x6D},
    {0x65, 0x69, 0x6A, 0x69},
    {0x6E, 0x69, 0x74, 0x61}
};
//S盒
int S_box[256] =
{
	0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
	0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
	0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
	0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
	0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
	0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
	0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
	0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
	0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
	0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
	0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
	0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
	0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
	0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
	0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
	0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16
};
//轮常数
vector<int> round10 = {
    0x01, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 
    0x08, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 
    0x20, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 
    0x1B, 0x00, 0x00, 0x00, 
    0x36, 0x00, 0x00, 0x00  
};

//逆S盒
int IS[256] =
{
	0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
	0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
	0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
	0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
	0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
	0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
	0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
	0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
	0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
	0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
	0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
	0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
	0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
	0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
	0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
	0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
};

//列混淆中的固定矩阵
int colmix_matrix[16] = {
	0x02, 0x03, 0x01, 0x01,
    0x01, 0x02, 0x03, 0x01,
    0x01, 0x01, 0x02, 0x03,
    0x03, 0x01, 0x01, 0x02
};

//对单个16进制2位数进行s盒代换
int byte_replacement(int hex_2_byte){
	int aa = (hex_2_byte >> 4) & 0xff;
	int bb = hex_2_byte-aa*16;
	return S_box[aa*16+bb];
}

void fuc1(vector<col> &orikey,int cnt, int *s){
	//字节旋转
	col ciallo = orikey[cnt-1];
	rotate(ciallo.begin(),ciallo.begin()+1,ciallo.end());
	
	//字节替换
	col tmp;
	for(int i: ciallo){
		tmp.push_back(byte_replacement(i));
	}
	
	//异或操作
	col mygo = orikey[cnt-4];
	col rr;
	for(int i = 0;i<4;++i){
		rr.push_back((mygo[i]^round10[cnt%4*4+i]^tmp[i]));
	}
	orikey.push_back(rr);
}

void fuc2(vector<col> &orikey,int cnt){
	col tmp;
	for(int i = 0;i<4;++i){
		tmp.push_back((orikey[cnt-1][i]^orikey[cnt-4][i]));
	}
	orikey.push_back(tmp);
}

vector<col>expand_orikey16(vector<col> orikey,int round){

	for(int i = 4;i<=round*4+3;++i){
		if(i%4 == 0) fuc1(orikey,i,S_box);
		else fuc2(orikey,i);
	}
	
	return orikey;
}
//行（列）移位
void col_shift(vector<col> &matrix4x4){
	int shifts[4] = {0, 1, 2, 3};
	
	for (int i = 1; i < 4; ++i) {
        int shift = shifts[i];
		col tmp = {};
		for(int j = 0;j<4;++j){
			tmp.push_back(matrix4x4[j][i]);
		}

		rotate(tmp.begin(),tmp.begin()+shift,tmp.end());

		for(int j = 0;j<4;++j){
			matrix4x4[j][i] = tmp[j];
		}
    }
}
//GF(2^8)模乘运算！！！
int gf28_multiply(int a, int b) {
    int result = 0;
    for (int i = 0; i < 8; ++i) {
        if (b & 1) { // 如果 b 的最低位为 1
            result ^= a; // 累加 a
        }
        b >>= 1; // 右移 b
        if (a & 0x80) { // 如果 a 的最高位为 1
            a = (a << 1) ^ 0x11B; // 模 x^8 + x^4 + x^3 + x + 1
        } else {
            a <<= 1; // 左移 a
        }
    }
    return result;
}
//列（行）混淆
vector<col> row_mix(vector<col> matrix4x4){
	vector<col> rmatrix4x4 = matrix4x4;
	for(int i=0;i<4;++i){
		for(int j = 0;j<4;++j){
			int ciallo = 0;
			for(int k=0;k<4;++k){
				ciallo ^= gf28_multiply(matrix4x4[i][k],colmix_matrix[j*4+k]);
			}
			rmatrix4x4[i][j] = ciallo;
		}
		
	}
	return rmatrix4x4;
}

vector<col> AES_Encrypt(vector<col>M16,vector<col>KEY_expand){
	vector<col>state = M16;
	//种子密钥异或
	for(int i = 0;i<M16.size();++i){
		for (int j = 0;j<M16.size();++j){
			state[i][j] ^= KEY_expand[i][j];
		}
	}
	//轮操作
	for(int cnt = 1;cnt<=9;++cnt){
		//字节替换
		for(int i = 0;i<M16.size();++i){
			for (int j = 0;j<M16.size();++j){
				state[i][j] = byte_replacement(state[i][j]);
			}
		}
		//行移位（实际在这段代码中是列移位）
		col_shift(state);
		//列混淆（实际为行混淆）
		state = row_mix(state);
		//轮密钥加
		for(int i = 0;i<4;++i){
			for (int j = 0;j<4;++j){
				state[i][j] ^= KEY_expand[cnt*4+i][j];
			}
		}		
	}
	//最后一轮
	for(int i = 0;i<M16.size();++i){
		for (int j = 0;j<M16.size();++j){
			state[i][j] = byte_replacement(state[i][j]);
		}
	}
	col_shift(state);
	for(int i = 0;i<4;++i){
		for (int j = 0;j<4;++j){
			state[i][j] ^= KEY_expand[40+i][j];
		}
	}

	return state;
}

int main() {
	vector<col> key176 = expand_orikey16(ORIKEY16,10);
    vector<col> C16 = AES_Encrypt(M16,key176);
	cout << "加密后密文矩阵为："<<endl;
	for(auto i :C16){
		for(auto j:i){
			cout << "0x" << hex << setw(2) << setfill('0') << j << " ";
		}
		cout << endl;
	}

    return 0;
}
